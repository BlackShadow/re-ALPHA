/***
*
*    Copyright (c) 1996-1997, Valve LLC. All rights reserved.
*
*    This product contains software technology licensed from Id
*    Software, Inc ("Id Technology"). Id Technology (c) 1996 Id Software, Inc.
*    All Rights Reserved.
*
****/
//
// qc.cpp: Half-Life Alpha MDL Decompiler.
//

#include "mdldec.h"

#pragma pack(push, 1)
struct alpha_legacy_event_t
{
    short frame;
    unsigned char event;
    unsigned char type;
};
#pragma pack(pop)

void CMDLDecompiler::QC_GenerateScript()
{
    if (!m_pstudiohdr)
        return;

    char qcfilename[_MAX_PATH];
    char path[_MAX_PATH];

    GetModelName();
    sprintf(qcfilename, "%s%s.qc", DestPath, ModelName);

    strcpy(path, ".");

    qcfile = fopen(qcfilename, "w");
    if (!qcfile)
    {
        LogMessage(MDLDEC_MSG_ERROR, "ERROR: Can't write %s\r\n", qcfilename);
        return;
    }

    fprintf(qcfile, "/*\n");
    fprintf(qcfile, "==============================================================================\n\n");
    fprintf(qcfile, "QC script generated by Half-Life Alpha MDL Decompiler v%s.\n", MDLDEC_VERSION);
    fprintf(qcfile, "%s.qc\n", ModelName);
    fprintf(qcfile, "Original model name: %s\n\n", m_pstudiohdr->name);
    fprintf(qcfile, "==============================================================================\n");
    fprintf(qcfile, "*/\n\n");

    fprintf(qcfile, "$modelname \"%s.mdl\"\n", ModelName);
    fprintf(qcfile, "$cd \"%s\\\"\n", path);
    fprintf(qcfile, "$cdtexture \"%s\\maps_8bit\\\"\n", path);
    fprintf(qcfile, "$scale 1.0\n");

    if (m_pstudiohdr->numtextures == 0)
        fprintf(qcfile, "$externaltextures\n");

    fprintf(qcfile, "\n");

    QC_WriteBodyModels();
    QC_WriteTextureGroups();
    QC_WriteBoneControllers();
    QC_WriteSequences();

    fprintf(qcfile, "\n// End of QC file.\n");
    fclose(qcfile);
    qcfile = NULL;

    LogMessage(MDLDEC_MSG_INFO, "QC Script: %s\r\n", qcfilename);
}

void CMDLDecompiler::QC_WriteTextureGroups()
{
    if (!m_ptexturehdr || !qcfile)
        return;

    studiohdr_t *phdr = m_ptexturehdr;
    if (phdr->numskinfamilies <= 1 || phdr->numskinref <= 0)
        return;

    short *pskinindex = (short *)((byte *)phdr + phdr->skinindex);

    fprintf(qcfile, "\n// %i skin families\n", phdr->numskinfamilies);
    fprintf(qcfile, "$texturegroup skinfamilies\n{\n");

    for (int i = 0; i < phdr->numskinfamilies; ++i)
    {
        fprintf(qcfile, "{");
        for (int j = 0; j < phdr->numskinref; ++j)
        {
            short *pskinref = pskinindex + (i * phdr->numskinref) + j;
            mstudiotexture_t *pTexture =
                (mstudiotexture_t *)((byte *)phdr + phdr->textureindex + sizeof(mstudiotexture_t) * (*pskinref));
            fprintf(qcfile, " \"%s\"", pTexture->name);
        }
        fprintf(qcfile, " }\n");
    }

    fprintf(qcfile, "}\n");
}

void CMDLDecompiler::QC_WriteBodyModels()
{
    if (!m_pstudiohdr || !qcfile)
        return;

    fprintf(qcfile, "\n// reference meshes\n");

    for (int i = 0; i < m_pstudiohdr->numbodyparts; ++i)
    {
        mstudiobodyparts_t *pbodyparts =
            (mstudiobodyparts_t *)((byte *)m_pstudiohdr + m_pstudiohdr->bodypartindex + sizeof(mstudiobodyparts_t) * i);

        if (pbodyparts->nummodels == 1)
        {
            mstudiomodel_t *pmodel = (mstudiomodel_t *)((byte *)m_pstudiohdr + pbodyparts->modelindex);
            char tmpname[64];
            strncpy(tmpname, pmodel->name, sizeof(tmpname) - 1);
            tmpname[sizeof(tmpname) - 1] = 0;
            MyExtractFileBase(tmpname, tmpname);
            fprintf(qcfile, "$body %s \"%s\"\n\n", pbodyparts->name, tmpname);
        }
        else
        {
            fprintf(qcfile, "$bodygroup %s\n", pbodyparts->name);
            fprintf(qcfile, "{\n");
            for (int j = 0; j < pbodyparts->nummodels; ++j)
            {
                mstudiomodel_t *pmodel =
                    (mstudiomodel_t *)((byte *)m_pstudiohdr + pbodyparts->modelindex + sizeof(mstudiomodel_t) * j);
                if (_strnicmp(pmodel->name, "blank", 5) == 0)
                {
                    fprintf(qcfile, "blank\n");
                }
                else
                {
                    char tmpname[64];
                    strncpy(tmpname, pmodel->name, sizeof(tmpname) - 1);
                    tmpname[sizeof(tmpname) - 1] = 0;
                    MyExtractFileBase(tmpname, tmpname);
                    fprintf(qcfile, "studio \"%s\"\n", tmpname);
                }
            }
            fprintf(qcfile, "}\n");
        }
    }
}

void CMDLDecompiler::QC_WriteBoneControllers()
{
    if (!m_pstudiohdr || !qcfile || m_pstudiohdr->numbonecontrollers <= 0)
        return;

    mstudiobonecontroller_t *pcontrollers =
        (mstudiobonecontroller_t *)((byte *)m_pstudiohdr + m_pstudiohdr->bonecontrollerindex);

    fprintf(qcfile, "\n// %i bone controllers\n", m_pstudiohdr->numbonecontrollers);
    for (int i = 0; i < m_pstudiohdr->numbonecontrollers; ++i)
    {
        char mflag[64];
        QC_TranslateMotionFlag(pcontrollers[i].type & ~STUDIO_RLOOP, mflag, false);

        char boneName[64];
        GetBoneName(pcontrollers[i].bone, boneName, sizeof(boneName));

        fprintf(qcfile,
                "$controller %i \"%s\" %s %f %f",
                i,
                boneName,
                mflag[0] ? mflag : "X",
                pcontrollers[i].start,
                pcontrollers[i].end);

        if (pcontrollers[i].type & STUDIO_RLOOP)
            fprintf(qcfile, " loop");
        fprintf(qcfile, "\n");
    }
}

void CMDLDecompiler::QC_WriteSequences()
{
    if (!m_pstudiohdr || !qcfile)
        return;

    fprintf(qcfile, "\n// %i animation sequences\n", m_pstudiohdr->numseq);

    for (int i = 0; i < m_pstudiohdr->numseq; ++i)
    {
        const mstudioseqdesc_t *pseqdesc = GetSequenceDesc(i);
        if (!pseqdesc)
            continue;

        fprintf(qcfile, "$sequence \"%s\" \"%s\" ", pseqdesc->label, pseqdesc->label);

        if (pseqdesc->motiontype != 0)
        {
            char flagstring[128];
            QC_TranslateMotionFlag(pseqdesc->motiontype, flagstring, true);
            fprintf(qcfile, "%s ", flagstring);
        }

        fprintf(qcfile, "fps %.0f ", pseqdesc->fps);
        if (pseqdesc->flags & STUDIO_LOOPING)
            fprintf(qcfile, "loop ");

        const byte *seqRaw = reinterpret_cast<const byte *>(pseqdesc);
        const int legacyNumEvents = *reinterpret_cast<const int *>(seqRaw + 40);
        const int legacyEventIndex = *reinterpret_cast<const int *>(seqRaw + 44);
        const int modernNumEvents = pseqdesc->numevents;
        const int modernEventIndex = pseqdesc->eventindex;
        bool wroteEvents = false;

        if (modernNumEvents > 0)
        {
            size_t eventOffset = (size_t)modernEventIndex;
            size_t eventBytes = (size_t)modernNumEvents * sizeof(mstudioevent_t);
            if (eventOffset > 0 && eventOffset + eventBytes <= CoreFile.size())
            {
                const mstudioevent_t *events =
                    reinterpret_cast<const mstudioevent_t *>(CoreFile.data() + eventOffset);

                fprintf(qcfile, "{\n");
                for (int ev = 0; ev < modernNumEvents; ++ev)
                {
                    const mstudioevent_t &e = events[ev];
                    fprintf(qcfile, "event %d %d", e.event, e.frame);
                    if (e.options[0] != 0)
                    {
                        fprintf(qcfile, " \"%s\"", e.options);
                    }
                    fprintf(qcfile, "\n");
                }
                fprintf(qcfile, "}\n");
                wroteEvents = true;
            }
        }

        if (!wroteEvents && legacyNumEvents > 0 && legacyNumEvents <= MAXSTUDIOEVENTS)
        {
            size_t eventOffset = (size_t)legacyEventIndex;
            size_t eventBytes = (size_t)legacyNumEvents * sizeof(alpha_legacy_event_t);
            if (eventOffset > 0 && eventOffset + eventBytes <= CoreFile.size())
            {
                const alpha_legacy_event_t *events =
                    reinterpret_cast<const alpha_legacy_event_t *>(CoreFile.data() + eventOffset);

                fprintf(qcfile, "{\n");
                for (int ev = 0; ev < legacyNumEvents; ++ev)
                {
                    fprintf(qcfile, "event %u %d\n", (unsigned int)events[ev].event, (int)events[ev].frame);
                }
                fprintf(qcfile, "}\n");
                wroteEvents = true;
            }
        }

        if (!wroteEvents)
        {
            fprintf(qcfile, "\n");
            if (modernNumEvents > 0 || legacyNumEvents > 0)
            {
                LogMessage(MDLDEC_MSG_WARNING,
                           "WARNING: Sequence \"%s\" has invalid events block "
                           "(modern index=%d count=%d, legacy index=%d count=%d).\r\n",
                           pseqdesc->label,
                           modernEventIndex,
                           modernNumEvents,
                           legacyEventIndex,
                           legacyNumEvents);
            }
        }
    }
}

void CMDLDecompiler::QC_TranslateMotionFlag(int mflag, char *string, bool addtostring)
{
    string[0] = 0;

    if (!addtostring)
    {
        switch (mflag)
        {
        case STUDIO_X:
            strcpy(string, "X");
            break;
        case STUDIO_Y:
            strcpy(string, "Y");
            break;
        case STUDIO_Z:
            strcpy(string, "Z");
            break;
        case STUDIO_XR:
            strcpy(string, "XR");
            break;
        case STUDIO_YR:
            strcpy(string, "YR");
            break;
        case STUDIO_ZR:
            strcpy(string, "ZR");
            break;
        case STUDIO_LX:
            strcpy(string, "LX");
            break;
        case STUDIO_LY:
            strcpy(string, "LY");
            break;
        case STUDIO_LZ:
            strcpy(string, "LZ");
            break;
        case STUDIO_AX:
            strcpy(string, "AX");
            break;
        case STUDIO_AY:
            strcpy(string, "AY");
            break;
        case STUDIO_AZ:
            strcpy(string, "AZ");
            break;
        case STUDIO_XRT:
            strcpy(string, "XRT");
            break;
        case STUDIO_YRT:
            strcpy(string, "YRT");
            break;
        case STUDIO_ZRT:
            strcpy(string, "ZRT");
            break;
        case STUDIO_QT:
            strcpy(string, "QT");
            break;
        default:
            strcpy(string, "X");
            break;
        }
        return;
    }

    if (mflag & STUDIO_X)
        strcat(string, " X");
    if (mflag & STUDIO_Y)
        strcat(string, " Y");
    if (mflag & STUDIO_Z)
        strcat(string, " Z");
    if (mflag & STUDIO_XR)
        strcat(string, " XR");
    if (mflag & STUDIO_YR)
        strcat(string, " YR");
    if (mflag & STUDIO_ZR)
        strcat(string, " ZR");
    if (mflag & STUDIO_LX)
        strcat(string, " LX");
    if (mflag & STUDIO_LY)
        strcat(string, " LY");
    if (mflag & STUDIO_LZ)
        strcat(string, " LZ");
    if (mflag & STUDIO_AX)
        strcat(string, " AX");
    if (mflag & STUDIO_AY)
        strcat(string, " AY");
    if (mflag & STUDIO_AZ)
        strcat(string, " AZ");
    if (mflag & STUDIO_XRT)
        strcat(string, " XRT");
    if (mflag & STUDIO_YRT)
        strcat(string, " YRT");
    if (mflag & STUDIO_ZRT)
        strcat(string, " ZRT");
}
